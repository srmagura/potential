#        def convert(points):
#            x = []
#            y = []

#            for p in points:
#                x1, y1 = get_coord(*p)
#                x.append(x1)
#                y.append(y1)

#            return x, y

#        if plot_grid:
#            plt.plot(*convert(M0), marker='o', label='M0', ms=1, linestyle='',
#                color='black')
#            plt.plot(*convert(gamma), marker='^', label='M0', ms=4, linestyle='',
#                color='red')
            #plt.plot(*convert(Mplus), marker='o', label='Mplus', linestyle='',
            #    color='gray')
            #plt.plot(*convert(Nplus), marker='x', label='Nplus', ms=9, linestyle='',
            #    color='black')

#            xdata = []
#            ydata = []
#            for th in np.linspace(0, 4*np.pi, 2000):
#                xdata.append(R*np.cos(th))
#                ydata.append(R*np.sin(th))

#            plt.plot(xdata, ydata, color='blue')
#            plt.xlim(-4,4)
#            plt.ylim(-4,4)
            #plt.legend()
#            plt.show()
            



        #if verbose:
        #    fourier_test(c0, 'c0', self.problem.eval_expected)
        #    fourier_test(c1, 'c1', 
        #        self.problem.eval_expected_derivative)

    # Prints the error caused by truncating the Fourier series.
#    def fourier_test(self, c, name, expected):
#        error = []
#        exp = []
#        act = []
#        step = .01

#        th_range = np.arange(0, 2*np.pi, step)
#        for th in th_range:
#            x = 0
#            for J in J_dict:
#                x += c[J_dict[J]] * cmath.exp(complex(0, J*th))

#            error.append(abs(x - expected(th)))
#            act.append(x)
#            exp.append(expected(th))

#        print('Fourier error ({}): '.format(name), max(error))
